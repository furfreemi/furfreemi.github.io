

SYN floods were the first network attack I learned about, and I absolutely loved it



Syn cookies explanation:
The Linux kernel maintains two queues to track TCP connections for each port- a syn/incomplete connection queue, and an accepted/complete connection queue. When a port receives a connection request (a SYN packet), it responds with a SYN-ACK and stores this pending connection in the syn queue. When the client eventually sends the final part of the handshake, the ACK, then the connection is removed from the syn queue and added to the accepted queue. Memory is finite, so these queues have a given allocated max size. Checking the value of net.ipv4.tcp_max_syn_backlog, we see that our server has 128 slots in that queue. When there are 128 pending connections (SYN-ACK sent, waiting on an ACK) and another SYN comes in, the kernel doesn’t have a place to track this connection, so it isn’t able to continue on with the connection process, and the client isn’t able to fully connect.
There’s a few ways to improve this situation- the queue size could be increased to allow for more connections, we can expire (remove from the queue) potentially illegitimate or dropped connections waiting on ACK’s more quickly to clear up space for new connections that might be more legitimate (current default- 63 seconds), or we could come up with an alternative to the queue altogether.
Syn cookies are a route that bypass the queue altogether. The mechanism kicks in when the queue is full and it receives a connection request. Rather than storing connection information in this queue, the server instead encodes essential connection information within the initial sequence number sent along with the SYN-ACK packet. This number will be included by the client’s ACK packet in the form of the acknowledgement number incremented by 1, so upon receiving an ACK that doesn’t align with a partial connection in the syn queue, the server can retrieve this ‘cookie’ by decrementing the ACK packet’s ack number and reversing the encoding to get necessary connection information and establish a full connection in the ‘accept’ queue. This is more computationally expensive, but requires no queue memory space during connection set up. An additional downside is that there may be limits to the amount of information that can be encoded and stored in the 32b sequence number field. Encoded info: MSS (approximate, as there are limited values that can be encoded) and a timestamp.